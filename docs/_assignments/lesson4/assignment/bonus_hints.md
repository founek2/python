# Problém obecně

Tato úloha je zaměřena na úlohy z teorie grafů. Zadanou matici uložíme jako list listů. Tuto matici (mapu openspace) si můžeme představit jako graf tak, že každá buňka je vrchol grafu a buňky sousedící do 4 směrů jsou sousedé daného vrcholu. Abychom tuto úlohu mohli vyřešit v čase O(2*m*n) = O(m\*n), tak budeme potřebovat jeden ze základních algoritmů tohoto oboru, čímž je prohledávání do šířky (BFS). Python nemá standardně mezi datovými strukturami (list, dict, set,...) frontu, která je potřeba pro tento algoritmus. Frontu sice můžeme nasimulovat pomocí datového typu list, ale to by nám zvýšilo časovou složitost, protože list odebírá prvek na začátku v čase O(n). V Pythonu máme https://docs.python.org/3/library/collections.html#collections.deque datovou strukturu, která představuje oboustrannou frontu (dá se přidávat/odebírat z konce/začátku) a to v čase O(1). Je to právě pro tyto účely optimalizované. Pro použití stačí napsat na začátek:
from collections import deque. Pro přidání na konec je zde metoda append a pro odebrání ze začátku je zde metoda popleft. Metoda popleft odebere prvek a vrátí vám ho jejím voláním. Více viz dokumentace.

## Řešení pomocí fronty:

Tento problém tedy se dá řešit tak, že nejdříve projedeme celou matici a všechny nakažené naházíme do fronty společně s jejich souřadnicemi (dobré je mít z důvodu počítání dnů ve frontě vždy trojici (x, y, den_nakazeni). Po naplnění této fronty začneme s while cyklem s ukončovací podmínkou závislou na neprázdnosti fronty, tedy while len(fronta) > 0. V těle tohoto cyklu nejdříve vyjmeme prvek na začátku fronty a přičteme jedničku k počtu nakažených. Pro tento prvek se pak koukáme do všech 4 směrů, jestli je možné někoho nakazit. Pokud je to možné, tak událost zapíšeme do mapy a nově nakaženého opět uložíme jako trojici do fronty s tím, že den nakažení bude o 1 větší, než právě testovaného. Abysme určili počet dnů nakažení, stačí při každém přidání nově infikovaného do fronty si uložit jeho den nakažení.
